{"name":"pfs","tagline":"A dockerized distributed file system.","body":"# Pachyderm File System\r\n\r\n## What is pfs?\r\nPfs is a distributed file system built specifically for the Docker\r\necosystem. You [deploy it with Docker](https://registry.hub.docker.com/u/pachyderm/pfs/),\r\njust like other applications in your stack. Furthermore,\r\nMapReduce jobs are specified as Docker containers, rather than .jars,\r\nletting you perform distributed computation using any tools you want.\r\n\r\n## Key Features\r\n*TODO* make these clickable to lower sections\r\n- Fault-tolerant architecture built on [CoreOS](https://coreos.com) (implemented)\r\n- Git-like distributed file system (implemented)\r\n- Dockerized MapReduce (not implemented)\r\n\r\n## Is pfs production ready\r\nNo, pfs is at Alpha status.\r\n\r\n## Where is this project going?\r\nLong term Pachyderm's goal is to be a viable alternative to Hadoop built on top\r\nof a modern distributed computing toolchain. Hadoop is a mature product so\r\nthere's a great deal of work to be done to match its feature set. However we're\r\nfinding that thanks to innovative tools like btrfs, Docker and CoreOS we can\r\nbuild more functionality with less code than was possible 10 years ago.\r\n\r\n## What is a \"git-like file system\"?\r\nPfs is implemented as a distributed layer on top of btrfs, the same\r\ncopy-on-write(CoW) filesystem that powers Docker. A distributed layer that\r\nhorizontally scales btrfs' existing\r\n[git-like](http://zef.me/6023/who-needs-git-when-you-got-zfs/) semantics to\r\ndatacenter scale datasets. Pfs brings features like commit based history and\r\nbranching, standard primitives for collaborating on code, data engineering.\r\n\r\n## What is \"dockerized MapReduce?\"\r\nThe basic interface for MapReduce is a `map` function and a `reduce` function.\r\nIn Hadoop this is exposed as a Java interface. In Pachyderm MapReduce jobs are\r\nuser submitted Docker containers with http servers inside them. Rather than\r\ncalling a `map` method on a class Pachyderm POSTs files to the `/map` route on\r\na webserver. This completely democratizes MapReduce by decoupling it from a\r\nsingle platform such as the JVM.\r\n\r\n## Quickstart Guide\r\n\r\n### Creating a CoreOS cluster\r\nPfs is designed to run on CoreOS. To start you'll need a working CoreOS\r\ncluster. Currently global containers, which are required by pfs, are only\r\navailable in the beta channel (CoreOS 444.5.0.)\r\n\r\n- [Vagrant](https://coreos.com/docs/running-coreos/platforms/vagrant/) (reccommended)\r\n- [Google Compute Engine](https://coreos.com/docs/running-coreos/cloud-providers/google-compute-engine/)\r\n- [Amazon EC2](https://coreos.com/docs/running-coreos/cloud-providers/ec2/)\r\n\r\n### Deploy pfs\r\nSSH in to one of your new machines CoreOS machines.\r\n\r\n`$ wget https://github.com/pachyderm-io/pfs/raw/master/deploy/static/1Node.tar.gz`\r\n\r\n`$ tar -xvf 1Node.tar.gz`\r\n\r\n`$ fleetctl start 1Node/*`\r\n\r\nThe startup process takes a little while the first time your run it because\r\neach node has to pull a Docker image.\r\n\r\n### Checking the status of your deploy\r\nThe easiest way to see what's going on in your cluster is to use `list-units`\r\n```shell\r\n$ fleetctl list-units\r\n```\r\n\r\nIf things are working correctly you should see something like:\r\n\r\n```\r\nUNIT                            MACHINE                         ACTIVE  SUB\r\nannounce-master-0-1.service     3817102d.../10.240.199.203      active  running\r\nannounce-replica-0-1.service    3817102d.../10.240.199.203      active  running\r\nmaster-0-1.service              3817102d.../10.240.199.203      active  running\r\nreplica-0-1.service             3817102d.../10.240.199.203      active  running\r\nrouter.service                  3817102d.../10.240.199.203      active  running\r\n```\r\n\r\n### Using pfs\r\nPfs exposes a git like interface to the file system:\r\n\r\n#### Creating a file\r\n```shell\r\n$ curl -XPOST localhost/pfs/file_name -d @local_file\r\n```\r\n\r\n#### Read a file\r\n```shell\r\n$ curl localhost/pfs/file_name\r\n```\r\n\r\n#### Creating/modifying a file\r\n```shell\r\n$ curl -XPUT localhost/pfs/file_name -d @local_file\r\n```\r\n\r\n#### Deleting a file\r\n```shell\r\n$ curl -XDELETE localhost/pfs/file_name\r\n```\r\n\r\n#### Committing changes\r\n```shell\r\n$ curl localhost/commit\r\n```\r\n\r\nCommitting in pfs creates a lightweight snapshot of the file system state and\r\npushes it to replicas. Where it remains accessible by commit id.\r\n\r\n### Accessing previous commits\r\n```shell\r\n$ curl localhost/pfs/file_name?commit=n\r\n```\r\n\r\n## Who's building this?\r\n2 guys who love data and communities. Both of whom are named Joe. We'd love\r\nto chat: joey.zwicker@gmail.com jdoliner@gmail.com.\r\n\r\n## How do I hack on pfs?\r\nPfs' only dependency is Docker. You can build it like so:\r\n```shell\r\npfs$ docker build -t username/pfs .\r\n```\r\nDeploying what you build requires pushing the built container to the central\r\nDocker registry and changing the container name in the .service files from\r\n`pachyderm/pfs` to `username/pfs`.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}